- name: "Quickstart-quickstart"
  content: "Note: Before proceeding, install Manim and make sure it’s running properly by following the steps in Installation. For information on using Manim with Jupyterlab or Jupyter notebook, go to the documentation for the IPython magic command, %%manim."
  description: "Reminder to ensure Manim is installed and running properly before starting."

- name: "Overview-quickstart"
  content: "This quickstart guide will lead you through creating a sample project using Manim: an animation engine for precise programmatic animations. First, you will use a command line interface to create a Scene, the class through which Manim generates videos. In the Scene you will animate a circle. Then you will add another Scene showing a square transforming into a circle. This will be your introduction to Manim’s animation ability. Afterwards, you will position multiple mathematical objects (Mobjects). Finally, you will learn the .animate syntax, a powerful feature that animates the methods you use to modify Mobjects."
  description: "Introduction to the quickstart guide, outlining the steps for creating a sample project using Manim."

- name: "Starting a new project-quickstart"
  content: "Start by creating a new folder. For the purposes of this guide, name the folder project:\n\nproject/\n\nThis folder is the root folder for your project. It contains all the files that Manim needs to function, as well as any output that your project produces."
  description: "Instructions for starting a new Manim project by creating a project folder."

- name: "Animating a circle-quickstart"
  content: "Open a text editor, such as Notepad. Copy the following code snippet into the window:\n\nfrom manim import *\n\nclass CreateCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n        self.play(Create(circle))  # show the circle on screen\n\nSave the code snippet into your project folder with the name scene.py.\n\nproject/\n└─scene.py\n\nOpen the command line, navigate to your project folder, and execute the following command:\n\nmanim -pql scene.py CreateCircle\n\nManim will output rendering information, then create an MP4 file. Your default movie player will play the MP4 file, displaying the following animation.\n\nIf you see an animation of a pink circle being drawn, congratulations! You just wrote your first Manim scene from scratch.\n\nIf you get an error message instead, you do not see a video, or if the video output does not look like the preceding animation, it is likely that Manim has not been installed correctly. Please refer to our FAQ section for help with the most common issues."
  description: "Guide for animating a circle in Manim, including code snippets and command line instructions."

- name: "Explanation-quickstart"
  content: "Let’s go over the script you just executed line by line to see how Manim was able to draw the circle.\n\nThe first line imports all of the contents of the library:\n\nfrom manim import *\n\nThis is the recommended way of using Manim, as a single script often uses multiple names from the Manim namespace. In your script, you imported and used Scene, Circle, PINK and Create.\n\nNow let’s look at the next two lines:\n\nclass CreateCircle(Scene):\n    def construct(self):\n        [...]\n\nMost of the time, the code for scripting an animation is entirely contained within the construct() method of a Scene class. Inside construct(), you can create objects, display them on screen, and animate them.\n\nThe next two lines create a circle and set its color and opacity:\n\ncircle = Circle()  # create a circle\ncircle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n\nFinally, the last line uses the animation Create to display the circle on your screen:\n\nself.play(Create(circle))  # show the circle on screen\n\nTip: All animations must reside within the construct() method of a class derived from Scene. Other code, such as auxiliary or mathematical functions, may reside outside the class."
  description: "Detailed explanation of the script used to animate a circle, including code import, class creation, and method usage."

- name: "Transforming a square into a circle-quickstart"
  content: "With our circle animation complete, let’s move on to something a little more complicated.\n\nOpen scene.py, and add the following code snippet below the CreateCircle class:\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set color and transparency\n\n        square = Square()  # create a square\n        square.rotate(PI / 4)  # rotate a certain amount\n\n        self.play(Create(square))  # animate the creation of the square\n        self.play(Transform(square, circle))  # interpolate the square into the circle\n        self.play(FadeOut(square))  # fade out animation\n\nRender SquareToCircle by running the following command in the command line:\n\nmanim -pql scene.py SquareToCircle\n\nThe following animation will render:\n\nThis example shows one of the primary features of Manim: the ability to implement complicated and mathematically intensive animations (such as cleanly interpolating between two geometric shapes) with just a few lines of code."
  description: "Instructions for transforming a square into a circle in Manim, highlighting the library's ability to handle complex animations."

- name: "Positioning Mobjects-quickstart"
  content: "Next, let’s go over some basic techniques for positioning Mobjects.\n\nOpen scene.py, and add the following code snippet below the SquareToCircle method:\n\nclass SquareAndCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n\n        square = Square()  # create a square\n        square.set_fill(BLUE, opacity=0.5)  # set the color and transparency\n\n        square.next_to(circle, RIGHT, buff=0.5)  # set the position\n        self.play(Create(circle), Create(square))  # show the shapes on screen\n\nRender SquareAndCircle by running the following command in the command line:\n\nmanim -pql scene.py SquareAndCircle\n\nThe following animation will render:\n\nnext_to is a Mobject method for positioning Mobjects.\n\nWe first specified the pink circle as the square’s reference point by passing circle as the method’s first argument. The second argument is used to specify the direction the Mobject is placed relative to the reference point. In this case, we set the direction to RIGHT, telling Manim to position the square to the right of the circle. Finally, buff=0.5 applied a small distance buffer between the two objects.\n\nTry changing RIGHT to LEFT, UP, or DOWN instead, and see how that changes the position of the square.\n\nUsing positioning methods, you can render a scene with multiple Mobjects, setting their locations in the scene using coordinates or positioning them relative to each other.\n\nFor more information on next_to and other positioning methods, check out the list of Mobject methods in our reference manual."
  description: "Guide on positioning Mobjects in Manim, including examples of using the next_to method."

- name: "Using .animate syntax to animate methods-quickstart"
  content: "The final lesson in this tutorial is using .animate, a Mobject method which animates changes you make to a Mobject. When you prepend .animate to any method call that modifies a Mobject, the method becomes an animation which can be played using self.play. Let’s return to SquareToCircle to see the differences between using methods when creating a Mobject, and animating those method calls with .animate.\n\nOpen scene.py, and add the following code snippet below the SquareAndCircle class:\n\nclass AnimatedSquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        square = Square()  # create a square\n\n        self.play(Create(square))  # show the square on screen\n        self.play(square.animate.rotate(PI / 4))  # rotate the square\n        self.play(Transform(square, circle))  # transform the square into a circle\n        self.play( square.animate.set_fill(PINK, opacity=0.5) )  # color the circle on screen\n\nRender AnimatedSquareToCircle by running the following command in the command line:\n\nmanim -pql scene.py AnimatedSquareToCircle\n\nThe following animation will render:\n\nThe first self.play creates the square. The second animates rotating it 45 degrees. The third transforms the square into a circle, and the last colors the circle pink. Although the end result is the same as that of SquareToCircle, .animate shows rotate and set_fill being applied to the Mobject dynamically, instead of creating them with the changes already applied.\n\nTry other methods, like flip or shift, and see what happens.\n\nOpen scene.py, and add the following code snippet below the AnimatedSquareToCircle class:\n\nclass DifferentRotations(Scene):\n    def construct(self):\n        left_square = Square(color=BLUE, fill_opacity=0.7).shift(2 * LEFT)\n        right_square = Square(color=GREEN, fill_opacity=0.7).shift(2 * RIGHT)\n        self.play( left_square.animate.rotate(PI), Rotate(right_square, angle=PI), run_time=2 )\n        self.wait()\n\nRender DifferentRotations by running the following command in the command line:\n\nmanim -pql scene.py DifferentRotations\n\nThe following animation will render:\n\nThis Scene illustrates the quirks of .animate. When using .animate, Manim actually takes a Mobject’s starting state and its ending state and interpolates the two. In the AnimatedSquareToCircle class, you can observe this when the square rotates: the corners of the square appear to contract slightly as they move into the positions required for the first square to transform into the second one.\n\nIn DifferentRotations, the difference between .animate’s interpretation of rotation and the Rotate method is far more apparent. The starting and ending states of a Mobject rotated 180 degrees are the same, so .animate tries to interpolate two identical objects and the result is the left square. If you find that your own usage of .animate is causing similar unwanted behavior, consider using conventional animation methods like the right square, which uses Rotate."
  description: "Explanation and examples of using .animate syntax in Manim to animate method calls."

- name: "Transform vs ReplacementTransform-quickstart"
  content: "The difference between Transform and ReplacementTransform is that Transform(mob1, mob2) transforms the points (as well as other attributes like color) of mob1 into the points/attributes of mob2.\n\nReplacementTransform(mob1, mob2) on the other hand literally replaces mob1 on the scene with mob2.\n\nThe use of ReplacementTransform or Transform is mostly up to personal preference. They can be used to accomplish the same effect, as shown below.\n\nclass TwoTransforms(Scene):\n    def transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(Transform(a, b))\n        self.play(Transform(a, c))\n        self.play(FadeOut(a))\n\n    def replacement_transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(ReplacementTransform(a, b))\n        self.play(ReplacementTransform(b, c))\n        self.play(FadeOut(c))\n\n    def construct(self):\n        self.transform()\n        self.wait(0.5)  # wait for 0.5 seconds\n        self.replacement_transform()\n\nHowever, in some cases it is more beneficial to use Transform, like when you are transforming several mobjects one after the other. The code below avoids having to keep a reference to the last mobject that was transformed.\n\nExample: TransformCycle \n\nfrom manim import *\n\nclass TransformCycle(Scene):\n    def construct(self):\n        a = Circle()\n        t1 = Square()\n        t2 = Triangle()\n        self.add(a)\n        self.wait()\n        for t in [t1,t2]:\n            self.play(Transform(a,t))"
  description: "Explanation of the difference between Transform and ReplacementTransform in Manim, including examples of their usage."

- name: "You’re done!-quickstart"
  content: "With a working installation of Manim and this sample project under your belt, you’re ready to start creating animations of your own. To learn more about what Manim is doing under the hood, move on to the next tutorial: Manim’s Output Settings. For an overview of Manim’s features, as well as its configuration and other settings, check out the other Tutorials. For a list of all available features, refer to the Reference Manual page."
  description: "Conclusion of the quickstart guide, encouraging further exploration of Manim's features and settings."
